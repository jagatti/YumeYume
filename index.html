<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ロングノーツ譜面デモ</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#0f172a;overflow:hidden;display:flex;justify-content:center;align-items:center;font-family:system-ui;}
  #rotateMsg{position:fixed;inset:0;z-index:10;background:#000;color:#fff;display:none;justify-content:center;align-items:center;font-size:2rem;}
  #startBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:2.2rem;padding:0.8em 2.2em;background:#39ff14;color:#0f172a;border:none;border-radius:1em;box-shadow:0 6px 32px #39ff1440;cursor:pointer;z-index:100;}
  #startBtn:hover{background:#27ac0e;color:#fff;}
  canvas{background:#1e293b;border:2px solid #334155;border-radius:10px;touch-action:none;display:block;}
</style>
</head>
<body>
<div id="rotateMsg">横画面にしてください</div>
<canvas id="game"></canvas>
<button id="startBtn">S.T.A.R.T!!</button>
<script>
// --------------------
// 譜面データ
// --------------------
const notesChart = [
  { time: 1.0, side: "left" },                             // 1秒目 左タップ
  { time: 2.0, side: "right" },                            // 2秒目 右タップ
  { time: 3.0, side: "left", type: "long", endTime: 5.0 }, // 3秒目 左ロング 5秒目離す
  { time: 6.0, side: "right", type: "long", endTime: 8.0 },// 6秒目 右ロング 8秒目離す
  { time: 9.0, side: "right", type: "long", endTime: 11.0 },// 9秒目 右ロング 11秒目離す
  { time: 11.0, side: "left" },                            // 11秒目 左タップ
  { time: 12.0, side: "left", type: "long", endTime: 14.0 },// 12秒目 左ロング 14秒目離す
  { time: 14.0, side: "right" },                           // 14秒目 右タップ
  { time: 15.0, side: "left", type: "long", endTime: 17.0 },// 15秒目 左ロング 17秒目離す
  { time: 16.0, side: "right" },                           // 16秒目 右タップ
  { time: 17.0, side: "right" },                           // 17秒目 右タップ
];

// --------------------
// ゲーム変数
// --------------------
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
const rotateMsg = document.getElementById('rotateMsg');
const startBtn = document.getElementById('startBtn');
const SONG_TITLE = "ロングノーツ譜面デモ";

let chartIndex = 0, R=36, leftTarget={x:0,y:0,r:0}, rightTarget={x:0,y:0,r:0};
let score=0, combo=0, notes=[], frame=0, gameState = "init", countdownValue = 3, totalNotesSpawned = 0, clearStartFrame = null, resultStartFrame = null;
let popups=[], hitRings=[], lastInputWasTouch=false;
let judgeCount = {WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
let longNoteState = {left: null, right: null}; // {startFrame, noteIndex, holding, judgedRelease}
let noteDuration = 80; // ノーツの速さ
let holdTouch = {left: null, right: null}; // タッチID保存
let progressDisplay = 0;

// --------------------
// レイアウト計算
// --------------------
function resizeCanvas(){
  const landscape = window.innerWidth >= window.innerHeight;
  if(!landscape){
    rotateMsg.style.display='flex';
    cvs.style.display='none';
    startBtn.style.display='none';
    return;
  }
  rotateMsg.style.display='none';
  cvs.style.display='block';
  if(gameState==="init") startBtn.style.display='block';
  else startBtn.style.display='none';
  cvs.width = window.innerWidth;
  cvs.height= window.innerHeight;
  const minDim=Math.min(cvs.width, cvs.height);
  R = Math.max(24, Math.round(minDim*0.048));
  const laneGap = R*4.5;
  const targetY = Math.round(cvs.height*0.7);
  leftTarget  ={x: Math.round(cvs.width/2 - laneGap), y: targetY, r: R};
  rightTarget ={x: Math.round(cvs.width/2 + laneGap), y: targetY, r: R};
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --------------------
// ノーツ生成
// --------------------
function cubicBezier(p0,p1,p2,p3,t){const u=1-t;return {x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y};}
function makePath(side){const target= side==='left'? leftTarget : rightTarget;const startX = side==='left' ? (-R*2-10) : (cvs.width+R*2+10);const start={x:startX, y: target.y - Math.max(180, R*6)};const c1={x: side==='left' ? target.x - Math.max(200,R*6) : target.x + Math.max(200,R*6), y: target.y - Math.max(200,R*6)};const c2={x: side==='left' ? target.x - Math.max(60,R*2)  : target.x + Math.max(60,R*2),  y: target.y - Math.max(40,R*1.3)};const end={x: target.x, y: target.y};return {p0:start,p1:c1,p2:c2,p3:end};}
function spawnNote(n){
  if(n.type === "long"){
    const duration = noteDuration;
    const durationEnd = Math.round((n.endTime-n.time)*60); // 秒→フレーム
    notes.push({
      type: "long",
      side: n.side,
      t: 0,
      duration,
      durationEnd,
      path: makePath(n.side),
      released: false,
      endT: durationEnd,
      chart: n
    });
  }else{
    notes.push({
      type: "tap",
      side: n.side,
      t: 0,
      duration: noteDuration,
      path: makePath(n.side)
    });
  }
}

// --------------------
// 判定・入力
// --------------------
function addPopup(text,x,y,ms,type){const d=Math.max(1,Math.round(ms/16.67));popups.push({text,x,y,timer:d,duration:d,type});}
function awardHit(target, points, label, resetCombo){
  score+=points;
  if(resetCombo){combo=0;}
  else combo++;
  hitRings.push({x:target.x,y:target.y,r:target.r,alpha:1});
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  addPopup(String(points), midX, midY, 500, 'score');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
}
function applyMiss(label='MISS'){
  combo=0;
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
}

function judgeNotesTap(mx, my){
  let bestIdx=-1, bestDist=Infinity, bestTarget=null;
  for(let i=0;i<notes.length;i++){
    const n=notes[i];
    if(n.type !== "tap") continue;
    const target=n.side==='left'?leftTarget:rightTarget;
    const pos=cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const judgeDist=Math.hypot(pos.x-mx, pos.y-my);
    if(judgeDist<bestDist){bestDist=judgeDist; bestIdx=i; bestTarget=target;}
  }
  if(bestIdx>=0 && bestDist < R*1.3){
    awardHit(bestTarget, 5000, "WONDERFUL", false);
    notes.splice(bestIdx,1);
    return true;
  }
  return false;
}

// ロングノーツ判定（タッチ開始時）
function tryHoldLongNote(mx, my, touchId){
  // 長押し中のノーツがなければ開始
  for(let i=0;i<notes.length;i++){
    const n = notes[i];
    if(n.type !== "long" || n.released) continue;
    // 既にhold中なら無視
    const lane = n.side;
    if(longNoteState[lane] && longNoteState[lane].holding) continue;
    // 位置判定
    const target = lane==='left'?leftTarget:rightTarget;
    const pos = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const dist = Math.hypot(pos.x-mx, pos.y-my);
    if(dist < R*1.3 && n.t < n.duration+20){ // 開始点判定
      longNoteState[lane] = {startFrame: frame, noteIndex: i, holding: true, judgedRelease: false, touchId};
      holdTouch[lane] = touchId;
      awardHit(target, 5000, "WONDERFUL", false); // 開始判定
      return true;
    }
  }
  return false;
}

// ロングノーツリリース判定
function tryReleaseLongNote(mx, my, lane){
  const state = longNoteState[lane];
  if(!state || !state.holding) return false;
  const n = notes[state.noteIndex];
  if(!n || n.type!=="long" || n.released) return false;
  // 判定タイミング
  const tRelease = n.t;
  const endWin = 28;
  const nearEnd = Math.abs(tRelease - n.endT) < endWin;
  const target = lane==='left'?leftTarget:rightTarget;
  if(nearEnd){
    awardHit(target, 6200, "WONDERFUL", false); // リリース判定
    n.released = true;
    longNoteState[lane] = null;
    return true;
  }else{
    applyMiss("BAD");
    n.released = true;
    longNoteState[lane] = null;
    return false;
  }
}

// タッチ操作
let ongoingTouches = {}; // id: {x,y}
cvs.addEventListener('touchstart', function(e){
  if(gameState !== "playing") return;
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    const rect=cvs.getBoundingClientRect();
    const scaleX = cvs.width  / rect.width;
    const scaleY = cvs.height / rect.height;
    const mx=(t.clientX-rect.left)*scaleX;
    const my=(t.clientY-rect.top )*scaleY;
    ongoingTouches[t.identifier] = {x:mx, y:my};
    // まずロングノーツ判定
    if(tryHoldLongNote(mx, my, t.identifier)) continue;
    // 通常タップ
    if(judgeNotesTap(mx, my)) continue;
    // ミス
    applyMiss("MISS");
  }
});
cvs.addEventListener('touchmove', function(e){
  if(gameState !== "playing") return;
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    const rect=cvs.getBoundingClientRect();
    const scaleX = cvs.width  / rect.width;
    const scaleY = cvs.height / rect.height;
    const mx=(t.clientX-rect.left)*scaleX;
    const my=(t.clientY-rect.top )*scaleY;
    ongoingTouches[t.identifier] = {x:mx, y:my};
  }
});
cvs.addEventListener('touchend', function(e){
  if(gameState !== "playing") return;
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    const pos = ongoingTouches[t.identifier];
    if(!pos) continue;
    // ロングノーツリリース判定
    for(const lane of ["left","right"]){
      if(holdTouch[lane] === t.identifier){
        tryReleaseLongNote(pos.x, pos.y, lane);
        holdTouch[lane] = null;
      }
    }
    delete ongoingTouches[t.identifier];
  }
});
cvs.addEventListener('touchcancel', function(e){
  // キャンセル時もBAD
  if(gameState !== "playing") return;
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    for(const lane of ["left","right"]){
      if(holdTouch[lane] === t.identifier){
        applyMiss("BAD");
        holdTouch[lane] = null;
        longNoteState[lane] = null;
      }
    }
    delete ongoingTouches[t.identifier];
  }
});

// PC用クリック操作
cvs.addEventListener('mousedown', function(e){
  if(gameState !== "playing") return;
  const rect=cvs.getBoundingClientRect();
  const mx=(e.clientX-rect.left)*cvs.width/rect.width;
  const my=(e.clientY-rect.top )*cvs.height/rect.height;
  // ロングノーツ判定
  if(tryHoldLongNote(mx, my, "_mouse")) return;
  // 通常タップ
  if(judgeNotesTap(mx, my)) return;
  // ミス
  applyMiss("MISS");
});
cvs.addEventListener('mouseup', function(e){
  if(gameState !== "playing") return;
  for(const lane of ["left","right"]){
    if(holdTouch[lane]==="_mouse"){
      const rect=cvs.getBoundingClientRect();
      const mx=(e.clientX-rect.left)*cvs.width/rect.width;
      const my=(e.clientY-rect.top )*cvs.height/rect.height;
      tryReleaseLongNote(mx, my, lane);
      holdTouch[lane] = null;
    }
  }
});

// --------------------
// ゲーム進行
// --------------------
startBtn.onclick = function() {
  if(gameState === "init"){
    chartIndex = 0;
    totalNotesSpawned = 0;
    notes = [];
    score=0; combo=0; progressDisplay=0;
    hitRings=[]; popups=[];
    frame = 0;
    countdownValue = 3;
    judgeCount = {WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
    longNoteState = {left:null, right:null};
    holdTouch = {left:null, right:null};
    ongoingTouches = {};
    gameState = "countdown";
    resizeCanvas();
    startBtn.style.display = "none";
  }
};

function update(){
  frame++;
  if(gameState==="countdown"){
    if(frame % 60 === 0 && countdownValue>0){
      countdownValue--;
      if(countdownValue===0){
        setTimeout(()=>{ gameState="playing"; frame = 0; },1000);
      }
    }
    return;
  }
  if (gameState === "playing") {
    const bgmNowSec = frame / 60;
    while (chartIndex < notesChart.length && bgmNowSec >= notesChart[chartIndex].time) {
      spawnNote(notesChart[chartIndex]);
      totalNotesSpawned++;
      chartIndex++;
    }
  }
  for(const n of notes){
    n.t++;
    // ロングノーツでholdなし・まだリリースしてないならBAD
    if(n.type==="long" && !n.released && n.t > n.endT+14){
      // 離しが間に合わなかったらBAD
      applyMiss("BAD");
      n.released = true;
      if(longNoteState[n.side]) longNoteState[n.side] = null;
    }
  }
  // ノーツ除去
  notes = notes.filter(n=>!(n.type==="tap" && n.t>n.duration+5) && !(n.type==="long" && n.released && n.t>n.endT+15));
  // ロングノーツ長押し中なのに途中でタッチが消えた場合はBAD
  for(const lane of ["left","right"]){
    const state = longNoteState[lane];
    if(state && state.holding && !Object.values(holdTouch).includes(state.touchId)){
      applyMiss("BAD");
      longNoteState[lane] = null;
    }
  }
  // 終了判定
  if(gameState==="playing" && chartIndex>=notesChart.length && notes.length===0){
    gameState="clear";
    clearStartFrame=frame;
  }
  if(gameState==="clear" && frame-clearStartFrame>90){
    gameState="result";
    resultStartFrame=frame;
  }
  hitRings=hitRings.filter(r=>{r.r+=4; r.alpha-=0.06; return r.alpha>0;});
  popups=popups.filter(p=>{p.timer--; return p.timer>0;});
  const clearedNotes = chartIndex - notes.length;
  const targetProgress = notesChart.length>0 ? Math.min(1, clearedNotes / notesChart.length) : 0;
  progressDisplay += (targetProgress - progressDisplay) * 0.2;
}

// --------------------
// 描画
// --------------------
function drawNotes(){
  ctx.save();
  for(const n of notes){
    if(n.type==="long"){
      // ロングノーツバー
      const startT = Math.min(1, n.t/n.duration);
      const endT = Math.min(1, n.endT/n.duration);
      const curT = Math.min(1, n.t/n.duration);
      const barStart = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, startT);
      const barEnd = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1, n.t/n.durationEnd, n.endT/n.duration));
      ctx.strokeStyle = "#ffe066";
      ctx.lineWidth = R * 0.85;
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.moveTo(barStart.x, barStart.y);
      ctx.lineTo(barEnd.x, barEnd.y);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // 始点
      ctx.beginPath();
      ctx.arc(barStart.x, barStart.y, R, 0, Math.PI * 2);
      ctx.fillStyle = "#ffe066";
      ctx.shadowColor = "#ffe066";
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      // 終端
      ctx.beginPath();
      ctx.arc(barEnd.x, barEnd.y, R*0.9, 0, Math.PI * 2);
      ctx.fillStyle = "#ffe066";
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#fff";
      ctx.stroke();
    }else{
      // 通常ノーツ
      const pos = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, R, 0, Math.PI*2);
      ctx.fillStyle = '#3b82f6';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#fff";
      ctx.stroke();
    }
  }
  ctx.restore();
}
function drawTargets(){
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  for(const t of [leftTarget,rightTarget]){
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawHitRings(){
  for(const ring of hitRings){
    ctx.strokeStyle=`rgba(255,255,255,${ring.alpha})`;
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(ring.x,ring.y,ring.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawPopups(){
  for(const p of popups){
    const a=p.timer/p.duration; ctx.globalAlpha=a;
    ctx.textAlign='center';
    ctx.font = `bold ${Math.max(24,R*1.0)}px system-ui`;
    ctx.fillStyle = p.type==='score' ? "#39ff14" : "#fff";
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha=1;
  }
}
function drawProgressBar(){
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const barHeight = 12;
  const x = barMarginLeft;
  const y = 10;
  ctx.fillStyle = '#4b5563';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = '#00e5ff';
  ctx.fillRect(x, y, barWidth * progressDisplay, barHeight);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, barWidth, barHeight);
}
function drawJudgeCountsResult() {
  const baseX = 30;
  const baseY = cvs.height - 28;
  const lineH = Math.max(14, Math.round(cvs.height * 0.03));
  const labels = ["WONDERFUL", "GREAT", "NICE", "BAD", "MISS"];
  ctx.save();
  ctx.textBaseline = 'top';
  ctx.font = `bold ${lineH}px system-ui`;
  let maxLabelWidth = 0, maxCountWidth = 0;
  for(const l of labels) {
    const w1 = ctx.measureText(l).width;
    const w2 = ctx.measureText(judgeCount[l].toString()).width;
    if(w1>maxLabelWidth) maxLabelWidth = w1;
    if(w2>maxCountWidth) maxCountWidth = w2;
  }
  const gap = 16;
  for(let i=0;i<labels.length;i++){
    const l = labels[i];
    const y = baseY - lineH * (labels.length - i);
    ctx.textAlign = 'left';
    ctx.fillStyle = "#fff";
    ctx.globalAlpha = 0.82;
    ctx.fillText(l, baseX, y);
    ctx.textAlign = 'right';
    ctx.fillStyle = "#ffd700";
    ctx.globalAlpha = 0.94;
    ctx.fillText(judgeCount[l], baseX + maxLabelWidth + gap + maxCountWidth, y);
  }
  ctx.globalAlpha = 1.0;
  ctx.restore();
}
function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  drawTargets();
  drawNotes();
  drawHitRings();
  drawPopups();
  drawProgressBar();

  if(gameState==="init"){ return; }
  if(gameState==="countdown"){
    const txt = countdownValue>0 ? countdownValue : 1;
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.22)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(txt, cvs.width/2, cvs.height/2);
    ctx.fillStyle='#fff'; ctx.fillText(txt, cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="clear"){
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.14)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#fff'; ctx.strokeText('CLEAR', cvs.width/2, cvs.height/2);
    ctx.fillStyle='#ffa500'; ctx.fillText('CLEAR', cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="result"){
    const t = Math.min(1, (frame - (resultStartFrame||frame)) / 60);
    const scale = 0.8 + 0.2*Math.sin(t*Math.PI/2);
    const alpha = 0.5 + 0.5*t;
    ctx.save();
    ctx.translate(cvs.width/2, cvs.height/2);
    ctx.scale(scale, scale);
    ctx.textAlign='center';
    ctx.shadowColor='rgba(255,165,0,0.6)';
    ctx.shadowBlur=16*alpha;
    ctx.globalAlpha=alpha;

    ctx.font=`bold ${Math.round(cvs.height*0.10)}px system-ui`;
    ctx.lineWidth=8; ctx.strokeStyle='#000'; ctx.strokeText('RESULT', 0, -90);
    ctx.fillStyle='#ffa500'; ctx.fillText('RESULT', 0, -90);

    const scoreFontSize = Math.round(cvs.height*0.07);
    ctx.font = `bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth = 8;
    ctx.strokeStyle = "#000";
    ctx.strokeText(SONG_TITLE, 0, -30);
    ctx.fillStyle = "#fff";
    ctx.fillText(SONG_TITLE, 0, -30);

    ctx.font=`bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(`SCORE: ${score}`, 0, 0);
    ctx.fillStyle='#39ff14'; ctx.fillText(`SCORE: ${score}`, 0, 0);

    ctx.font=`bold ${Math.round(cvs.height*0.04)}px system-ui`;
    ctx.lineWidth=6; ctx.strokeStyle='#000';
    ctx.strokeText(`COMBO: ${combo}`, 0, 48);
    ctx.fillStyle='#e5faff';
    ctx.fillText(`COMBO: ${combo}`, 0, 48);

    ctx.restore();
    drawJudgeCountsResult();
    return;
  }
}
function loop(){ update(); render(); requestAnimationFrame(loop); }
(function start(){ loop(); })();
</script>
</body>
</html>
