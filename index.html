<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>チュートリアル譜面リズムゲーム</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#0f172a;overflow:hidden;display:flex;justify-content:center;align-items:center;font-family:system-ui;}
  #rotateMsg{position:fixed;inset:0;z-index:10;background:#000;color:#fff;display:none;justify-content:center;align-items:center;font-size:2rem;}
  #startBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:2.2rem;padding:0.8em 2.2em;background:#39ff14;color:#0f172a;border:none;border-radius:1em;box-shadow:0 6px 32px #39ff1440;cursor:pointer;z-index:100;}
  #startBtn:hover{background:#27ac0e;color:#fff;}
  canvas{background:#1e293b;border:2px solid #334155;border-radius:10px;touch-action:none;display:block;}
</style>
</head>
<body>
<div id="rotateMsg">横画面にしてください</div>
<canvas id="game"></canvas>
<button id="startBtn">S.T.A.R.T!!</button>
<script>
// --- 基本変数とレイアウト ---
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
const rotateMsg = document.getElementById('rotateMsg');
const startBtn = document.getElementById('startBtn');

// --- チュートリアル譜面データ ---
// 1. 通常タップ（左右）→2. 左フリック→3. 右フリック→4. 上フリック→5. 下フリック
const notesChart = [
  { time: 0.80, side: "left" },                           // 左タップ
  { time: 1.50, side: "right" },                          // 右タップ
  { time: 2.20, side: "left", flick: "right" },           // 左レーン右フリック
  { time: 2.90, side: "right", flick: "left" },           // 右レーン左フリック
  { time: 3.60, side: "left", flick: "up" },              // 左レーン上フリック
  { time: 4.30, side: "right", flick: "down" },           // 右レーン下フリック
  { time: 5.00, side: "left" },                           // 左タップ
  { time: 5.30, side: "left", flick: "up" },              // 左上フリック
  { time: 5.60, side: "left", flick: "down" },            // 左下フリック
  { time: 6.00, side: "right", flick: "up" },             // 右上フリック
  { time: 6.30, side: "right", flick: "down" },           // 右下フリック
  { time: 7.00, side: "left" },                           // 左タップ
  { time: 7.50, side: "right" },                          // 右タップ
  { time: 8.00, side: "left", flick: "right" },           // 左右フリック
  { time: 8.30, side: "right", flick: "left" },           // 右左フリック
  { time: 9.00, side: "left" },                           // 左タップ
  { time: 9.50, side: "right" },                          // 右タップ
];

let chartIndex = 0, R=36, leftTarget={x:0,y:0,r:0}, rightTarget={x:0,y:0,r:0}, spRadius=80;
let SP_MAX=6000, spValue=0, spFullNotified=false, score=0, combo=0, notes=[], frame=0;
let noteDuration = 80;
let popups=[], hitRings=[], lastInputWasTouch=false;
let gameState = "init", countdownValue = 3, totalNotesSpawned = 0, clearStartFrame = null, resultStartFrame = null;
let skillActivationCount = 0, spUseCount = 0, progressDisplay = 0;

// 判定回数
let judgeCount = {WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
const SONG_TITLE = "チュートリアル譜面";

// --- レイアウト・ターゲット位置 ---
function resizeCanvas(){
  const landscape = window.innerWidth >= window.innerHeight;
  if(!landscape){
    rotateMsg.style.display='flex';
    cvs.style.display='none';
    startBtn.style.display='none';
    return;
  }
  rotateMsg.style.display='none';
  cvs.style.display='block';
  if(gameState==="init") startBtn.style.display='block';
  else startBtn.style.display='none';
  cvs.width = window.innerWidth;
  cvs.height= window.innerHeight;
  const minDim=Math.min(cvs.width, cvs.height);
  R = Math.max(24, Math.round(minDim*0.048));
  const laneGap = R*4.5;
  const targetY = Math.round(cvs.height*0.7);
  leftTarget  ={x: Math.round(cvs.width/2 - laneGap), y: targetY, r: R};
  rightTarget ={x: Math.round(cvs.width/2 + laneGap), y: targetY, r: R};
  spRadius = Math.max(64, Math.round(minDim*0.12));
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- ノーツパス ---
function cubicBezier(p0,p1,p2,p3,t){const u=1-t;return {x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y};}
function makePath(side){const target= side==='left'? leftTarget : rightTarget;const startX = side==='left' ? (-R*2-10) : (cvs.width+R*2+10);const start={x:startX, y: target.y - Math.max(180, R*6)};const c1={x: side==='left' ? target.x - Math.max(200,R*6) : target.x + Math.max(200,R*6), y: target.y - Math.max(200,R*6)};const c2={x: side==='left' ? target.x - Math.max(60,R*2)  : target.x + Math.max(60,R*2),  y: target.y - Math.max(40,R*1.3)};const end={x: target.x, y: target.y};return {p0:start,p1:c1,p2:c2,p3:end};}
function spawnNote(side, flick){ notes.push({side,t:0,duration:noteDuration,path:makePath(side), flick}); }
function addPopup(text,x,y,ms,type){const d=Math.max(1,Math.round(ms/16.67));popups.push({text,x,y,timer:d,duration:d,type});}
function awardHit(target, points, label, resetCombo){
  score+=points;
  if(resetCombo){combo=0;}
  else combo++;
  hitRings.push({x:target.x,y:target.y,r:target.r,alpha:1});
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  addPopup(String(points), midX, midY, 500, 'score');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
}
function applyMiss(label='MISS'){
  combo=0;
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  if(judgeCount[label] !== undefined) judgeCount[label]++;
}

// --- フリック方向検出 ---
function getFlickDirection(dx, dy) {
  if(Math.abs(dx) > Math.abs(dy)) {
    if(Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)*1.3) {
      return dx > 0 ? "right" : "left";
    }
  } else {
    if(Math.abs(dy) > 40 && Math.abs(dy) > Math.abs(dx)*1.3) {
      return dy > 0 ? "down" : "up";
    }
  }
  return null;
}

// --- 判定ロジック ---
function judgeNotesGlobal(){
  let bestIdx=-1, bestDist=Infinity, bestTarget=null;
  for(let i=0;i<notes.length;i++){
    const n=notes[i];
    if(n.flick) continue; // フリックは指フリックで判定
    const target=n.side==='left'?leftTarget:rightTarget;
    const pos=cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const judgeDist=Math.hypot(pos.x-target.x, pos.y-target.y);
    if(judgeDist<bestDist){bestDist=judgeDist; bestIdx=i; bestTarget=target;}
  }
  if(bestIdx>=0 && bestDist < R*1.3){
    awardHit(bestTarget, 5000, "WONDERFUL", false);
    notes.splice(bestIdx,1);
    return true;
  }
  return false;
}

// --- フリック判定 ---
function judgeFlick(dir, x, y){
  for(let i=0;i<notes.length;i++){
    const n=notes[i];
    if(!n.flick) continue;
    const target = n.side==='left'?leftTarget:rightTarget;
    const pos = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const dist = Math.hypot(pos.x - target.x, pos.y - target.y);
    if(dist < R*1.3 && n.flick === dir){
      awardHit(target, 5500, "WONDERFUL", false);
      notes.splice(i,1);
      return true;
    }
  }
  applyMiss('MISS');
  return false;
}

// --- タッチ・クリック入力 ---
let flickStart = null;
cvs.addEventListener('touchstart', (e) => {
  if (gameState !== "playing") return;
  const t = e.touches[0];
  flickStart = { x: t.clientX, y: t.clientY, time: performance.now() };
});
cvs.addEventListener('touchend', (e) => {
  if (gameState !== "playing" || !flickStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - flickStart.x;
  const dy = t.clientY - flickStart.y;
  const dt = performance.now() - flickStart.time;
  const dir = getFlickDirection(dx, dy);
  if(dt < 400 && dir) {
    judgeFlick(dir, flickStart.x, flickStart.y);
  } else {
    handlePointer(e);
  }
  flickStart = null;
});
function handlePointer(e){
  if(gameState!=="playing") return;
  if(judgeNotesGlobal()) return;
  applyMiss('MISS');
}
// --- PC用クリックにも対応 ---
cvs.addEventListener('click', handlePointer);

// --- STARTボタン ---
startBtn.onclick = function() {
  if(gameState === "init"){
    chartIndex = 0;
    totalNotesSpawned = 0;
    notes = [];
    spValue=0; spFullNotified=false;
    score=0; combo=0;
    skillActivationCount = 0;
    spUseCount = 0;
    progressDisplay = 0;
    hitRings=[]; popups=[];
    frame = 0;
    countdownValue = 3;
    judgeCount = {WONDERFUL:0,GREAT:0,NICE:0,BAD:0,MISS:0};
    gameState = "countdown";
    resizeCanvas();
    startBtn.style.display = "none";
  }
};

// --- ゲームループ ---
function update(){
  frame++;
  if(gameState==="countdown"){
    if(frame % 60 === 0 && countdownValue>0){
      countdownValue--;
      if(countdownValue===0){
        setTimeout(()=>{ gameState="playing"; frame = 0; },1000);
      }
    }
    return;
  }
  if (gameState === "playing") {
    const bgmNowSec = frame / 60;
    while (chartIndex < notesChart.length && bgmNowSec >= notesChart[chartIndex].time) {
      const n = notesChart[chartIndex];
      spawnNote(n.side, n.flick);
      totalNotesSpawned++;
      chartIndex++;
    }
  }
  for(const n of notes) n.t++;
  notes = notes.filter(n=>n.t<=n.duration+5);
  if(gameState==="playing" && chartIndex>=notesChart.length && notes.length===0){
    gameState="clear";
    clearStartFrame=frame;
  }
  if(gameState==="clear" && frame-clearStartFrame>90){
    gameState="result";
    resultStartFrame=frame;
  }
  hitRings=hitRings.filter(r=>{r.r+=4; r.alpha-=0.06; return r.alpha>0;});
  popups=popups.filter(p=>{p.timer--; return p.timer>0;});
  const clearedNotes = chartIndex - notes.length;
  const targetProgress = notesChart.length>0 ? Math.min(1, clearedNotes / notesChart.length) : 0;
  progressDisplay += (targetProgress - progressDisplay) * 0.2;
}

// --- 描画 ---
function drawFlickArrows(ctx, size, direction){
  ctx.save();
  if(direction==="right") ctx.rotate(Math.PI);
  if(direction==="up") ctx.rotate(Math.PI/2);
  if(direction==="down") ctx.rotate(-Math.PI/2);
  // 1本目
  ctx.beginPath();
  ctx.moveTo(-size*0.25, 0);
  ctx.lineTo(-size*0.7, -size*0.38);
  ctx.lineTo(-size*0.7, -size*0.18);
  ctx.lineTo(-size*0.95, -size*0.38);
  ctx.lineTo(-size*0.95, 0);
  ctx.lineTo(-size*0.7, size*0.18);
  ctx.lineTo(-size*0.7, size*0.38);
  ctx.closePath();
  ctx.fillStyle = "#fff";
  ctx.globalAlpha = 0.92;
  ctx.fill();
  // 2本目
  ctx.beginPath();
  ctx.moveTo(-size*0.05, 0);
  ctx.lineTo(-size*0.5, -size*0.28);
  ctx.lineTo(-size*0.5, -size*0.11);
  ctx.lineTo(-size*0.74, -size*0.28);
  ctx.lineTo(-size*0.74, 0);
  ctx.lineTo(-size*0.5, size*0.11);
  ctx.lineTo(-size*0.5, size*0.28);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();
}
function drawNotes(){
  ctx.save();
  for(const n of notes){
    const pos = cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    if(n.flick){
      // --- フリックノーツ・ピンク発光＋ダブル矢印 ---
      ctx.save();
      // 発光円
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, R, 0, Math.PI*2);
      ctx.shadowColor = "#f0abfc";
      ctx.shadowBlur = R * 1.2;
      ctx.fillStyle = "#e879f9";
      ctx.fill();
      ctx.shadowBlur = 0;
      // 白い円周
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      // ダブル矢印（方向ごとに回転）
      ctx.translate(pos.x, pos.y);
      drawFlickArrows(ctx, R, n.flick);
      ctx.restore();
    }else{
      // 通常ノーツ
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, R, 0, Math.PI*2);
      ctx.fillStyle = '#3b82f6';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#fff";
      ctx.stroke();
    }
  }
  ctx.restore();
}
function drawTargets(){
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  for(const t of [leftTarget,rightTarget]){
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawHitRings(){
  for(const ring of hitRings){
    ctx.strokeStyle=`rgba(255,255,255,${ring.alpha})`;
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(ring.x,ring.y,ring.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawPopups(){
  for(const p of popups){
    const a=p.timer/p.duration; ctx.globalAlpha=a;
    ctx.textAlign='center';
    ctx.font = `bold ${Math.max(24,R*1.0)}px system-ui`;
    ctx.fillStyle = p.type==='score' ? "#39ff14" : "#fff";
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha=1;
  }
}
function drawProgressBar(){
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const barHeight = 12;
  const x = barMarginLeft;
  const y = 10;
  ctx.fillStyle = '#4b5563';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = '#00e5ff';
  ctx.fillRect(x, y, barWidth * progressDisplay, barHeight);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, barWidth, barHeight);
}
function drawJudgeCountsResult() {
  const baseX = 30;
  const baseY = cvs.height - 28;
  const lineH = Math.max(14, Math.round(cvs.height * 0.03));
  const labels = ["WONDERFUL", "GREAT", "NICE", "BAD", "MISS"];
  ctx.save();
  ctx.textBaseline = 'top';
  ctx.font = `bold ${lineH}px system-ui`;
  let maxLabelWidth = 0, maxCountWidth = 0;
  for(const l of labels) {
    const w1 = ctx.measureText(l).width;
    const w2 = ctx.measureText(judgeCount[l].toString()).width;
    if(w1>maxLabelWidth) maxLabelWidth = w1;
    if(w2>maxCountWidth) maxCountWidth = w2;
  }
  const gap = 16;
  for(let i=0;i<labels.length;i++){
    const l = labels[i];
    const y = baseY - lineH * (labels.length - i);
    ctx.textAlign = 'left';
    ctx.fillStyle = "#fff";
    ctx.globalAlpha = 0.82;
    ctx.fillText(l, baseX, y);
    ctx.textAlign = 'right';
    ctx.fillStyle = "#ffd700";
    ctx.globalAlpha = 0.94;
    ctx.fillText(judgeCount[l], baseX + maxLabelWidth + gap + maxCountWidth, y);
  }
  ctx.globalAlpha = 1.0;
  ctx.restore();
}
function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  drawTargets();
  drawNotes();
  drawHitRings();
  drawPopups();
  drawProgressBar();

  if(gameState==="init"){ return; }
  if(gameState==="countdown"){
    const txt = countdownValue>0 ? countdownValue : 1;
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.22)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(txt, cvs.width/2, cvs.height/2);
    ctx.fillStyle='#fff'; ctx.fillText(txt, cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="clear"){
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.14)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#fff'; ctx.strokeText('CLEAR', cvs.width/2, cvs.height/2);
    ctx.fillStyle='#ffa500'; ctx.fillText('CLEAR', cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="result"){
    const t = Math.min(1, (frame - (resultStartFrame||frame)) / 60);
    const scale = 0.8 + 0.2*Math.sin(t*Math.PI/2);
    const alpha = 0.5 + 0.5*t;
    ctx.save();
    ctx.translate(cvs.width/2, cvs.height/2);
    ctx.scale(scale, scale);
    ctx.textAlign='center';
    ctx.shadowColor='rgba(255,165,0,0.6)';
    ctx.shadowBlur=16*alpha;
    ctx.globalAlpha=alpha;

    ctx.font=`bold ${Math.round(cvs.height*0.10)}px system-ui`;
    ctx.lineWidth=8; ctx.strokeStyle='#000'; ctx.strokeText('RESULT', 0, -90);
    ctx.fillStyle='#ffa500'; ctx.fillText('RESULT', 0, -90);

    const scoreFontSize = Math.round(cvs.height*0.07);
    ctx.font = `bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth = 8;
    ctx.strokeStyle = "#000";
    ctx.strokeText(SONG_TITLE, 0, -30);
    ctx.fillStyle = "#fff";
    ctx.fillText(SONG_TITLE, 0, -30);

    ctx.font=`bold ${scoreFontSize}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(`SCORE: ${score}`, 0, 0);
    ctx.fillStyle='#39ff14'; ctx.fillText(`SCORE: ${score}`, 0, 0);

    ctx.font=`bold ${Math.round(cvs.height*0.04)}px system-ui`;
    ctx.lineWidth=6; ctx.strokeStyle='#000';
    ctx.strokeText(`特技発動回数: ${skillActivationCount}`, 0, 48);
    ctx.strokeText(`SP使用回数: ${spUseCount}`, 0, 80);
    ctx.fillStyle='#e5faff';
    ctx.fillText(`特技発動回数: ${skillActivationCount}`, 0, 48);
    ctx.fillText(`SP使用回数: ${spUseCount}`, 0, 80);

    ctx.restore();
    drawJudgeCountsResult();
    return;
  }
}
function loop(){ update(); render(); requestAnimationFrame(loop); }
(function start(){ loop(); })();
</script>
</body>
</html>
