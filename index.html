<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>自作譜面リズムゲーム</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#0f172a;overflow:hidden;display:flex;justify-content:center;align-items:center;font-family:system-ui;}
  #rotateMsg{position:fixed;inset:0;z-index:10;background:#000;color:#fff;display:none;justify-content:center;align-items:center;font-size:2rem;}
  #startBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:2.2rem;padding:0.8em 2.2em;background:#39ff14;color:#0f172a;border:none;border-radius:1em;box-shadow:0 6px 32px #39ff1440;cursor:pointer;z-index:100;}
  #startBtn:hover{background:#27ac0e;color:#fff;}
  canvas{background:#1e293b;border:2px solid #334155;border-radius:10px;touch-action:none;display:block;}
</style>
</head>
<body>
<div id="rotateMsg">横画面にしてください</div>
<canvas id="game"></canvas>
<button id="startBtn" style="display:none;">ゲームスタート</button>
<audio id="bgm" src="YumeYume.mp3" preload="auto" loop></audio>
<script>
// --- 基本UI/Canvas設定 ---
const cvs=document.getElementById('game'), ctx=cvs.getContext('2d');
const rotateMsg=document.getElementById('rotateMsg');
const startBtn = document.getElementById('startBtn');
const bgm = document.getElementById('bgm');
bgm.volume = 0.10;

// --- 譜面データ対応（notesChart.jsonをfetchで読み込む） ---
let notesChart = [];
let chartIndex = 0;

fetch('notesChart.json')
  .then(res => res.json())
  .then(json => {
    notesChart = json;
    startBtn.style.display = "block"; // 譜面読み込み後にスタート可能
  });

// --- ゲーム状態変数 ---
let R=30, leftTarget={x:0,y:0,r:0}, rightTarget={x:0,y:0,r:0}, spRadius=80;
let SP_MAX=6000, spValue=0, spFullNotified=false, score=0, combo=0, notes=[], frame=0, noteDuration=45;
let spFlashTimer=0, spRingTimer=0, spRingSpeed=20, spRingRange=40, spBoostTimer=0, spCountdownTimer=0, spCountdownValue=0;
let popups=[], hitRings=[], lastInputWasTouch=false;
let gameState = "init", countdownValue = 3, totalNotesSpawned = 0, clearStartFrame = null, resultStartFrame = null;
let skillHistory = [], appealBoostNotes = 0, skillActivationCount = 0, spUseCount = 0, progressDisplay = 0;

// --- レイアウト&ターゲット設定 ---
function resizeCanvas(){
  const landscape = window.innerWidth >= window.innerHeight;
  if(!landscape){
    rotateMsg.style.display='flex';
    cvs.style.display='none';
    startBtn.style.display='none';
    return;
  }
  rotateMsg.style.display='none';
  cvs.style.display='block';
  if(gameState==="init" && notesChart.length>0) startBtn.style.display='block';
  else startBtn.style.display='none';
  cvs.width = window.innerWidth;
  cvs.height= window.innerHeight;

  const minDim=Math.min(cvs.width, cvs.height);
  R = Math.max(18, Math.round(minDim*0.04));
  const laneGap = R*4.5;
  const targetY = Math.round(cvs.height*0.7);
  leftTarget  ={x: Math.round(cvs.width/2 - laneGap), y: targetY, r: R};
  rightTarget ={x: Math.round(cvs.width/2 + laneGap), y: targetY, r: R};
  spRadius = Math.max(64, Math.round(minDim*0.12));
}
window.addEventListener('resize', resizeCanvas);resizeCanvas();

// --- ベジェパス・ノーツ生成 ---
function cubicBezier(p0,p1,p2,p3,t){
  const u=1-t;
  return {x:u*u*u*p0.x+3*u*u*t*p1.x+3*u*t*t*p2.x+t*t*t*p3.x,
          y:u*u*u*p0.y+3*u*u*t*p1.y+3*u*t*t*p2.y+t*t*t*p3.y};
}
function makePath(side){
  const target= side==='left'? leftTarget : rightTarget;
  const startX = side==='left' ? (-R*2-10) : (cvs.width+R*2+10);
  const start={x:startX, y: target.y - Math.max(180, R*6)};
  const c1={x: side==='left' ? target.x - Math.max(200,R*6) : target.x + Math.max(200,R*6), y: target.y - Math.max(200,R*6)};
  const c2={x: side==='left' ? target.x - Math.max(60,R*2)  : target.x + Math.max(60,R*2),  y: target.y - Math.max(40,R*1.3)};
  const end={x: target.x, y: target.y};
  return {p0:start,p1:c1,p2:c2,p3:end};
}
function spawnNote(side){ notes.push({side,t:0,duration:noteDuration,path:makePath(side)}); }

// --- ポップアップ・特技履歴などユーティリティ ---
function addPopup(text,x,y,ms,type){const d=Math.max(1,Math.round(ms/16.67));popups.push({text,x,y,timer:d,duration:d,type});}
function triggerSPVisual(){ spFlashTimer=10; spRingTimer=spRingSpeed; }
function calcTapBase(){let baseRaw=Math.floor(Math.random()*(4000-2500+1))+2500;if(appealBoostNotes>0){baseRaw = Math.ceil(baseRaw * 1.12);appealBoostNotes--;}return baseRaw;}
function calcTapScoreAndLabel(dist, baseRaw){
  let label='WONDERFUL', mult=1.2;
  if(dist<=6){label='WONDERFUL';mult=1.2;}
  else if(dist<=10){label='GREAT';mult=1.1;}
  else if(dist<=14){label='NICE';mult=1.0;}
  else if(dist<=18){label='BAD';mult=0.9;}
  else {return {points:0,label:'MISS',reset:true};}
  let points=Math.floor(baseRaw*mult);
  if(Math.random()<0.2){ points=Math.floor(points*1.5); label='CRITICAL'; }
  if(spBoostTimer>0) points=Math.floor(points*1.1);
  points=Math.min(5000, points);
  const reset = (label==='NICE' || label==='BAD');
  return {points,label,reset};
}
function awardHit(target, points, label, resetCombo, baseRaw){
  score+=points;
  if(resetCombo){if(spValue<SP_MAX) spValue=Math.max(0, spValue-300);combo=0;}
  else combo++;
  spValue=Math.min(SP_MAX, spValue+200);
  hitRings.push({x:target.x,y:target.y,r:target.r,alpha:1});
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
  addPopup(String(points), midX, midY, 500, 'score');
  if(Math.random() < 0.3){
    skillActivationCount++;
    const skillType = Math.floor(Math.random()*3);
    if(skillType===0){
      score += baseRaw;
      skillHistory.unshift({text:`[ボルテージ獲得 ${baseRaw}]`, life:180});
    }else if(skillType===1){
      spValue = Math.min(SP_MAX, spValue+540);
      skillHistory.unshift({text:`[SPゲージ獲得 9%]`, life:180});
    }else{
      appealBoostNotes = 5;
      skillHistory.unshift({text:`[アピール増加 12%]`, life:180});
    }
    if(skillHistory.length>5) skillHistory.pop();
  }
}
function applyMiss(label='MISS'){
  if(spValue<SP_MAX) spValue=Math.max(0, spValue-300);
  combo=0;
  const midX = (leftTarget.x + rightTarget.x) / 2;
  const midY = (leftTarget.y + rightTarget.y) / 2 - R*2;
  addPopup(label, midX, midY - 30, 500, 'label');
}
function isInSPSemicircle(mx,my){
  const cx=cvs.width/2, cy=cvs.height-10, r=spRadius;
  const dx=mx-cx, dy=my-cy, dist=Math.hypot(dx,dy);
  return (dist<=r) && (my<=cy);
}
function judgeNotesGlobal(){
  let bestIdx=-1, bestDist=Infinity, bestTarget=null;
  for(let i=0;i<notes.length;i++){
    const n=notes[i];
    const target=n.side==='left'?leftTarget:rightTarget;
    const pos=cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    const judgeDist=Math.hypot(pos.x-target.x, pos.y-target.y);
    if(judgeDist<bestDist){bestDist=judgeDist; bestIdx=i; bestTarget=target;}
  }
  if(bestIdx>=0){
    const baseRaw = calcTapBase();
    const {points,label,reset}=calcTapScoreAndLabel(bestDist, baseRaw);
    if(label!=='MISS'){
      awardHit(bestTarget, points, label, reset, baseRaw);
      notes.splice(bestIdx,1);
      return true;
    }else{ return false; }
  }
  return false;
}
function tryUseSP(mx,my){
  if(spValue<SP_MAX) return false;
  if(!isInSPSemicircle(mx,my)) return false;
  spUseCount++;
  score+=25000;
  spValue=0;
  spRingSpeed=10; spRingRange=80; triggerSPVisual();
  spBoostTimer=240;
  spCountdownTimer=240;
  spCountdownValue=3;
  addPopup('25000', cvs.width/2, cvs.height/2, 1000, 'sp');
  addPopup('', 0, 0, 180, 'flash');
  for(let i=0;i<6;i++){
    if(Math.random()<0.3){
      spValue = Math.min(SP_MAX, spValue + 600);
      skillHistory.unshift({text:`[SPゲージ獲得]`, life:180});
      if(skillHistory.length>5) skillHistory.pop();
    }
  }
  return true;
}

// --- 入力 ---
function handlePointer(e){
  if(gameState!=="playing") return;
  const isTouch = e.type.startsWith('touch');
  if(isTouch){ lastInputWasTouch=true; e.preventDefault(); }
  if(!isTouch && lastInputWasTouch){ lastInputWasTouch=false; return; }
  const rect=cvs.getBoundingClientRect();
  const clientX = isTouch ? e.touches[0].clientX : e.clientX;
  const clientY = isTouch ? e.touches[0].clientY : e.clientY;
  const scaleX = cvs.width  / rect.width;
  const scaleY = cvs.height / rect.height;
  const mx=(clientX-rect.left)*scaleX;
  const my=(clientY-rect.top )*scaleY;
  if(isInSPSemicircle(mx,my)){
    const used=tryUseSP(mx,my);
    if(!used) applyMiss('MISS');
    return;
  }
  if(judgeNotesGlobal()) return;
  applyMiss('MISS');
}
cvs.addEventListener('touchstart',handlePointer,{passive:false});
cvs.addEventListener('click',handlePointer);

// --- 開始ボタン ---
startBtn.onclick = function() {
  if(gameState === "init"){
    chartIndex = 0;
    totalNotesSpawned = 0;
    notes = [];
    spValue=0; spFullNotified=false;
    score=0; combo=0;
    skillHistory = [];
    appealBoostNotes = 0;
    skillActivationCount = 0;
    spUseCount = 0;
    progressDisplay = 0;
    spFlashTimer=0; spRingTimer=0; spRingSpeed=20; spRingRange=40;
    spBoostTimer=0;
    spCountdownTimer=0;
    spCountdownValue=0;
    popups=[]; hitRings=[];
    frame = 0;
    countdownValue = 3;
    gameState = "countdown";
    resizeCanvas();
    startBtn.style.display = "none";
  }
};

// --- update/ノーツ出現 ---
function update(){
  frame++;
  if(gameState==="countdown"){
    if(frame % 60 === 0 && countdownValue>0){
      countdownValue--;
      if(countdownValue===0){
        setTimeout(()=>{
          gameState="playing";
          frame = 0;
          bgm.currentTime = 0;
          bgm.volume = 0.10;
          bgm.play().catch(()=>{});
        },1000);
      }
    }
    return;
  }
  // JSON譜面に従ってノーツ出現
  if (gameState === "playing" && !bgm.paused) {
    const bgmNowSec = bgm.currentTime;
    while (chartIndex < notesChart.length && bgmNowSec >= notesChart[chartIndex].time) {
      spawnNote(notesChart[chartIndex].side);
      totalNotesSpawned++;
      chartIndex++;
    }
  }
  // ノーツ進行
  for(const n of notes) n.t++;
  // 期限超過→MISS
  const keep=[];for(const n of notes){if(n.t<=n.duration+5) keep.push(n);else applyMiss('MISS');}notes=keep;
  // 全ノーツ終了→CLEAR→2秒後にRESULT
  if(gameState==="playing" && chartIndex>=notesChart.length && notes.length===0){
    gameState="clear";
    clearStartFrame=frame;
    let fadeOut = setInterval(() => {
      if (bgm.volume > 0.02) { bgm.volume -= 0.02; }
      else { bgm.pause(); bgm.currentTime = 0; clearInterval(fadeOut); bgm.volume = 0.10; }
    }, 50);
  }
  if(gameState==="clear" && frame-clearStartFrame>120){
    gameState="result";
    resultStartFrame=frame;
  }
  // SP演出・満タン通知
  if(spValue>=SP_MAX){ if(!spFullNotified){ triggerSPVisual(); spFullNotified=true; } }
  else spFullNotified=false;
  // SPカウントダウン表示
  if(spCountdownTimer>0){ spCountdownTimer--; if(spCountdownTimer % 60 === 0){ spCountdownValue = Math.max(0, spCountdownValue-1); } }
  // 進捗バー
  const clearedNotes = chartIndex - notes.length;
  const targetProgress = notesChart.length>0 ? Math.min(1, clearedNotes / notesChart.length) : 0;
  progressDisplay += (targetProgress - progressDisplay) * 0.2;
  // 特技履歴寿命
  skillHistory.forEach(h=>h.life--);skillHistory = skillHistory.filter(h=>h.life>0);
  // 汎用演出寿命
  if(spFlashTimer>0) spFlashTimer--;
  if(spRingTimer>0)  spRingTimer--;
  if(spBoostTimer>0) spBoostTimer--;
  hitRings=hitRings.filter(r=>{r.r+=4; r.alpha-=0.06; return r.alpha>0;});
  popups=popups.filter(p=>{p.timer--; return p.timer>0;});
}

// --- 描画 ---
function strokeRainbowText(text,x,y,font){
  ctx.textAlign='center'; ctx.font=font;
  const g=ctx.createLinearGradient(x-100,y,x+100,y);
  const hue=(frame*4)%360;
  for(let i=0;i<=6;i++) g.addColorStop(i/6,`hsl(${(hue+i*60)%360},100%,50%)`);
  ctx.lineWidth=4; ctx.strokeStyle=g; ctx.strokeText(text,x,y);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function strokeColoredText(text,x,y,font,color){
  ctx.textAlign='center'; ctx.font=font;
  ctx.lineWidth=4; ctx.strokeStyle=color; ctx.strokeText(text,x,y);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function strokeOrangeWhiteText(text,x,y,font){
  ctx.textAlign='center'; ctx.font=font;
  ctx.lineWidth=6; ctx.strokeStyle='#fff'; ctx.strokeText(text,x,y);
  ctx.fillStyle='#ffa500'; ctx.fillText(text,x,y);
}
function drawProgressBar(){
  const barMarginLeft = 20;
  const barMarginRight = 200;
  const barWidth = Math.max(140, cvs.width - barMarginLeft - barMarginRight);
  const barHeight = 12;
  const x = barMarginLeft;
  const y = 10;
  ctx.fillStyle = '#4b5563';
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.fillStyle = '#00e5ff';
  ctx.fillRect(x, y, barWidth * progressDisplay, barHeight);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, barWidth, barHeight);
}
function drawSkillHistory(){
  const maxItems = 5;
  const lineH = Math.max(16, Math.round(R*0.6));
  const padding = 6;
  const x = 22;
  const startY = cvs.height - 22 - (maxItems-1)*lineH;
  ctx.textAlign='left';
  ctx.font=`bold ${lineH}px system-ui`;
  const items = skillHistory.slice(0, maxItems);
  for(let i=0;i<items.length;i++){
    const h=items[i];
    let alpha = 1;
    if(h.life < 30) alpha = h.life/30;
    ctx.globalAlpha = alpha;
    const text = h.text;
    const w = ctx.measureText(text).width;
    ctx.fillStyle='rgba(0,0,0,0.4)';
    ctx.fillRect(x-2, startY + i*lineH - (lineH-padding/2), w+16, lineH+padding/2);
    ctx.fillStyle='#e5faff';
    ctx.fillText(text, x, startY + i*lineH);
    ctx.globalAlpha = 1;
  }
}
function drawTargets(){
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  for(const t of [leftTarget,rightTarget]){
    ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawNotes(){
  ctx.fillStyle='#3b82f6';
  for(const n of notes){
    const pos=cubicBezier(n.path.p0,n.path.p1,n.path.p2,n.path.p3, Math.min(1,n.t/n.duration));
    ctx.beginPath(); ctx.arc(pos.x,pos.y,R,0,Math.PI*2); ctx.fill();
  }
}
function drawHitRings(){
  for(const ring of hitRings){
    ctx.strokeStyle=`rgba(255,255,255,${ring.alpha})`;
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(ring.x,ring.y,ring.r,0,Math.PI*2); ctx.stroke();
  }
}
function drawSPGauge(){
  const cx=cvs.width/2, cy=cvs.height-10, radius=spRadius;
  const startAngle=Math.PI, endAngle=0;
  ctx.strokeStyle='#fff'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.arc(cx,cy,radius,startAngle,endAngle,false); ctx.stroke();
  const fillRatio=Math.min(1, spValue/SP_MAX);
  const fillEnd=startAngle + Math.PI*fillRatio;
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,radius,startAngle,fillEnd,false); ctx.closePath(); ctx.fill();
  const nx=cx+Math.cos(fillEnd)*(radius-10), ny=cy+Math.sin(fillEnd)*(radius-10);
  ctx.strokeStyle='#fff'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(cx,cy,Math.max(3, radius*0.06),0,Math.PI*2); ctx.fill();
  if(spFlashTimer>0){
    ctx.fillStyle=`rgba(255,255,255,${spFlashTimer/10})`;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,radius,startAngle,endAngle,false); ctx.closePath(); ctx.fill();
  }
  if(spRingTimer>0){
    const rp=1 - spRingTimer/spRingSpeed;
    const rr=radius + rp*spRingRange;
    ctx.strokeStyle=`rgba(255,255,255,${1-rp})`;
    ctx.lineWidth=6; ctx.beginPath(); ctx.arc(cx,cy,rr,startAngle,endAngle,false); ctx.stroke();
  }
}
function drawPopups(){
  for(const p of popups){
    const a=p.timer/p.duration; ctx.globalAlpha=a;
    if(p.type==='label'){
      if(p.text==='CRITICAL'){
        ctx.fillStyle='#FFD700'; ctx.font=`bold ${Math.max(18,Math.round(R*0.7))}px system-ui`; ctx.textAlign='center';
        ctx.fillText('★', p.x-60, p.y);
        ctx.fillText('★', p.x+60, p.y);
        strokeRainbowText('CRITICAL', p.x, p.y, `bold ${Math.max(18,Math.round(R*0.7))}px system-ui`);
      }else if(p.text==='WONDERFUL'){
        strokeRainbowText('WONDERFUL', p.x, p.y, `bold ${Math.max(18,Math.round(R*0.7))}px system-ui`);
      }else if(p.text==='GREAT'){
        strokeColoredText('GREAT', p.x, p.y, `bold ${Math.max(18,Math.round(R*0.7))}px system-ui`, '#ff69b4');
      }else if(p.text==='NICE'){
        strokeColoredText('NICE', p.x, p.y, `bold ${Math.max(18,Math.round(R*0.7))}px system-ui`, '#ffd700');
      }else if(p.text==='BAD' || p.text==='MISS'){
        strokeColoredText(p.text, p.x, p.y, `bold ${Math.max(18,Math.round(R*0.7))}px system-ui`, '#9ca3af');
      }
    }else if(p.type==='score'){
      strokeColoredText(p.text, p.x, p.y, `bold ${Math.max(14,Math.round(R*0.5))}px system-ui`, '#39ff14');
    }else if(p.type==='sp'){
      strokeOrangeWhiteText(p.text, p.x, p.y, `bold ${Math.max(22,Math.round(R*1.1))}px system-ui`);
    }
    ctx.globalAlpha=1;
  }
}
function drawUI(){
  if(gameState!=="playing") return;
  const cx=cvs.width - Math.max(40, Math.round(R*1.8));
  ctx.textAlign='center'; ctx.fillStyle='#fff';
  ctx.font=`bold ${Math.max(20,Math.round(R*1.0))}px system-ui`; ctx.fillText(`${combo}`, cx, Math.max(24,Math.round(R*1.0)));
  ctx.font=`bold ${Math.max(10,Math.round(R*0.5))}px system-ui`; ctx.fillText('COMBO', cx, Math.max(40,Math.round(R*1.6)));
  ctx.textAlign='right'; ctx.font=`bold ${Math.max(14,Math.round(R*0.7))}px system-ui`;
  ctx.fillText(`Score: ${score}`, cvs.width-12, cvs.height-16);
}
function drawOverlays(){
  const f=popups.find(p=>p.type==='flash');
  if(f){
    ctx.fillStyle=`rgba(255,255,255,${f.timer/f.duration*0.6})`;
    ctx.fillRect(0,0,cvs.width,cvs.height);
  }
}
function drawSPCountdown(){
  if(spCountdownTimer<=0) return;
  if(spCountdownValue===0 && Math.floor(frame/8)%2===0) return;
  const x=cvs.width/2, y=Math.round(cvs.height*0.25);
  ctx.textAlign='center';
  ctx.font=`bold ${Math.max(48,Math.round(R*2.0))}px system-ui`;
  const g=ctx.createLinearGradient(x-80,y,x+80,y);
  const hue=(frame*4)%360;
  for(let i=0;i<=6;i++) g.addColorStop(i/6, `hsl(${(hue+i*60)%360},100%,50%)`);
  ctx.lineWidth=8; ctx.strokeStyle=g; ctx.strokeText(spCountdownValue, x, y);
  ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(spCountdownValue, x, y);
}
function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  drawTargets();
  drawNotes();
  drawHitRings();
  drawSPGauge();
  drawPopups();
  drawUI();
  drawOverlays();
  drawProgressBar();
  drawSkillHistory();
  if(gameState==="init"){ return; }
  if(gameState==="countdown"){
    const txt = countdownValue>0 ? countdownValue : 1;
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.22)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#000'; ctx.strokeText(txt, cvs.width/2, cvs.height/2);
    ctx.fillStyle='#fff'; ctx.fillText(txt, cvs.width/2, cvs.height/2);
    return;
  }
  drawSPCountdown();
  if(gameState==="clear"){
    ctx.textAlign='center';
    ctx.font=`bold ${Math.round(cvs.height*0.14)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeStyle='#fff'; ctx.strokeText('CLEAR', cvs.width/2, cvs.height/2);
    ctx.fillStyle='#ffa500'; ctx.fillText('CLEAR', cvs.width/2, cvs.height/2);
    return;
  }
  if(gameState==="result"){
    const t = Math.min(1, (frame - (resultStartFrame||frame)) / 60);
    const scale = 0.8 + 0.2*Math.sin(t*Math.PI/2);
    const alpha = 0.5 + 0.5*t;
    ctx.save();
    ctx.translate(cvs.width/2, cvs.height/2);
    ctx.scale(scale, scale);
    ctx.textAlign='center';
    ctx.shadowColor='rgba(255,165,0,0.6)';
    ctx.shadowBlur=40*alpha;
    ctx.globalAlpha=alpha;
    ctx.font=`bold ${Math.round(cvs.height*0.10)}px system-ui`;
    ctx.lineWidth=8; ctx.strokeStyle='#000'; ctx.strokeText('RESULT', 0, -90);
    ctx.fillStyle='#ffa500'; ctx.fillText('RESULT', 0, -90);
    ctx.font=`bold ${Math.round(cvs.height*0.07)}px system-ui`;
    ctx.lineWidth=10; ctx.strokeText(`SCORE: ${score}`, 0, 0);
    ctx.fillStyle='#39ff14'; ctx.fillText(`SCORE: ${score}`, 0, 0);
    ctx.font=`bold ${Math.round(cvs.height*0.04)}px system-ui`;
    ctx.lineWidth=6; ctx.strokeStyle='#000';
    ctx.strokeText(`特技発動回数: ${skillActivationCount}`, 0, 48);
    ctx.strokeText(`SP使用回数: ${spUseCount}`, 0, 80);
    ctx.fillStyle='#e5faff';
    ctx.fillText(`特技発動回数: ${skillActivationCount}`, 0, 48);
    ctx.fillText(`SP使用回数: ${spUseCount}`, 0, 80);
    ctx.restore();
    return;
  }
}
function loop(){ update(); render(); requestAnimationFrame(loop); }
(function start(){ loop(); })();
</script>
</body>
</html>
